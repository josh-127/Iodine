use regex;
use threading;
use net.socket;

_statusCodes = {
    200 : "200 OK",
    201 : "201 Created",
    202 : "202 Accepted",
    203 : "203 Non-Authoritative Information",
    204 : "204 No Content",
    205 : "205 Reset Content",
    206 : "206 Partial Content",
    300 : "300 Multiple Choices",
    301 : "301 Moved Permanently",
    302 : "302 Found",
    303 : "303 See Other",
    304 : "304 Not Modified",
    305 : "305 Use Proxy",
    306 : "306 Switch Proxy",
    307 : "307 Temporary Redirect",
    308 : "308 Permanent Redirect",
    400 : "400 Bad Request",
    401 : "401 Unauthorized",
    402 : "402 Payment Required",
    403 : "403 Forbidden",
    404 : "404 Not Found",
    405 : "405 Method Not Allowed",
    406 : "406 Not Acceptable",
    407 : "407 Proxy Authentication Required",
    408 : "408 Request Timeout",
    409 : "408 Request Timeout",
    410 : "410 Gone",
    411 : "411 Length Required",
    412 : "412 Precondition Failed",
    413 : "413 Payload Too Large",
    414 : "414 URI Too Long",
    415 : "415 Unsupported Media Type",
    416 : "416 Range Not Satisfiable",
    417 : "417 Expectation Failed",
    418 : "418 I'm a teapot",
    421 : "421 Misdirected Request",
    422 : "422 Unprocessable Entity",
    423 : "423 Locked",
    424 : "424 Failed Dependency",
    426 : "426 Upgrade Required",
    428 : "428 Precondition Required",
    429 : "429 Too Many Requests",
    431 : "431 Request Header Fields Too Large",
    451 : "451 Unavailable For Legal Reasons",
    500 : "500 Internal Server Error",
    501 : "501 Not Implemented",
    502 : "502 Bad Gateway",
    503 : "503 Service Unavailable",
    504 : "504 Gateway Timeout",
    505 : "505 HTTP Version Not Supprted",
    506 : "506 Variant Also Negotiates",
    507 : "507 Insufficient Storage",
    508 : "508 Loop Detected",
    509 : "509 Badwith Limit Exceeded",
    510 : "510 Not Extended",
    701 : "701 Meh",
    702 : "702 Emacs",
    703 : "703 Explosion",
    704 : "704 Goto Fail",
    705 : "705 I wrote the code and missed the necessary validation by an oversight (see 795)",
    710 : "710 PHP",
    711 : "711 Convenience Store",
    712 : "712 NoSQL",
    718 : "718 Haskell",
    719 : "719 I am not a teapot",
    720 : "720 Unpossible",
    721 : "721 Known Unknowns",
    722 : "722 Unknown Unknowns",
    723 : "723 Tricky",
    724 : "724 This line should be unreachable",
    725 : "725 It works on my machine",
    726 : "726 It's a feature, not a bug",
    727 : "727 32 bits is plenty",
    730 : "730 Fucking Bower",
    731 : "731 Fucking Rubygems",
    732 : "732 Fucking Unic:hankey:de",
    733 : "733 Fucking Deadlocks",
    734 : "734 Fucking Deferreds",
    735 : "735 Fucking IE",
    736 : "736 Fucking Race Conditions",
    737 : "737 FuckThreadsing",
    738 : "738 Fucking Bundler",
    739 : "739 Fucking Windows",
    740 : "740 Computer says no",
    741 : "741 Compiling",
    742 : "742 A kitten dies",
    743 : "743 I thought I knew regular expressions",
    744 : "744 Y U NO write integration tests?",
    745 : "745 I don't always test my code, but when I do I do it in production",
    746 : "746 Missed Ballmer Peak",
    747 : "747 Motherfucking Snakes on the Motherfucking Plane",
    748 : "748 Confounded by Ponies",
    749 : "749 Reserved for Chuck Norris",
    750 : "750 Didn't bother to compile it",
    753 : "753 Syntax Error",
    754 : "754 Too many semi-colons",
    755 : "755 Not enough semi-colons",
    756 : "756 Insufficiently polite",
    757 : "757 Excessively polite",
    759 : "759 Unexpected T_PAAMAYIM_NEKUDOTAYIM",
    761 : "761 Hungover",
    762 : "762 Stoned",
    763 : "763 Under-Caffeinated",
    764 : "764 Over-Caffeinated",
    765 : "765 Railscamp",
    766 : "766 Sober",
    767 : "767 Drunk",
    768 : "768 Accidentally Took Sleeping Pills Instead Of Migraine Pills During Crunch Week",
    769 : "769 Questionable Maturity Level",
    771 : "771 Cached for too long",
    772 : "772 Not cached long enough",
    773 : "773 Not cached at all",
    774 : "774 Why was this cached?",
    775 : "775 Out of cash",
    776 : "776 Error on the Exception",
    777 : "777 Coincidence",
    778 : "778 Off By One Error",
    779 : "779 Off By Too Many To Count Error",
    780 : "780 Project owner not responding",
    781 : "781 Operations",
    782 : "782 QA",
    783 : "783 It was a customer request, honestly",
    784 : "784 Management, obviously",
    785 : "785 TPS Cover Sheet not attached",
    786 : "786 Try it now",
    787 : "787 Further Funding Required",
    788 : "788 Designer's final designs weren't",
    789 : "789 Not my department",
    791 : "791 The Internet shut down due to copyright restrictions",
    792 : "792 Climate change driven catastrophic weather event",
    793 : "793 Zombie Apocalypse",
    794 : "794 Someone let PG near a REPL",
    795 : "795 #heartbleed (see 705)",
    797 : "797 This is the last page of the Internet. Go back",
    799 : "799 End of the world"
};

/*
 * Parse a query string and return a dict
 */
func parseQueryString (queryString) {
    if (queryString == null) {
        return {};
    }
    pairs = queryString.split("&");
    if (pairs[0] == "") {
        return {};
    }
    query_dict = {};
    for (pair in pairs) {
        pair_items = pair.split("=");
        query_dict[pair_items[0]] = unescapeQueryItem (pair_items[1]);
    }
    return query_dict;
}

func unescapeQueryItem (item) {
    item = item.replace ("+", " ");
    i = 0;
    accum = "";
    while (i < len (item)) {
        if (item [i] == "%") {
            ch = item [i + 1] + item [i + 2];
            accum += chr (Int (ch, 16));
            i += 3;
        } else {
            accum += item [i];
            i += 1;
        }
    }
    return accum;
}

/**
 * HTTP Request
 */
class HttpRequest {
    func HttpRequest (self) {
        self.parameters = {};
        self.postData = {};
    }
}

/**
 * HTTP Response 
 */
class HttpResponse {
    func HttpResponse (self) {
        self.headers = {};
        self._response = StringBuffer ();
        self.statusCode = 200;
    }
    
    /**
     * Writes a string of data to the response stream
     * @param data The data to be written
     */
    func write (self, data) {
        self._response.append (data);
    }
    
    /**
     * Writes a string of data to the response, appending
     * a new line to the data
     * @param line The line to be written
     */
    func writeln (self, line) {
        self._response.append (line + "\r\n");
    }
}

/**
 * Base HTTP Server class
 */
class BaseHttpServer {

    func BaseHttpServer (self) {
        self.routes = {};
        foo = HttpRequest ();
        self.sock = socket.socket (socket.SOCK_STREAM, socket.PROTO_TCP)
    }
    
    func handleRequest (self, response, request) {
        response.statusCode = 418;
    }
    
    func listen (self, host, port) {
        self.host =     host
        self.address =  host
        self.port =     port
        self.sock.bind (self.address, self.port)
        self.sock.listen (100)
        
        while (true) {
            client = self.sock.accept ();
            threading.Thread (lambda () => self._acceptConnection (client)).start ();
        }
    }
    
    func _acceptConnection (self, client) {
        try {
            with (stream = client.getstream ()) {
        
                req = stream.readln ();
                headers = {};
                do {
                    val = stream.readln ().trim ();
                
                    if (val.trim () == "") {
                        break;
                    }
            
                    field = val.split (':');
                    if (len (field) == 2) {
                        headers [field [0].trim ()]= field [1].trim ();
                    }
                } while (client.available () > 0);
        
                self._serveRequest (stream, req, headers);
            }
        } except (ex) {
            
        }
    }
    
    func _serveRequest (self, client, request, headers) {
        reqArgs = request.split (' ');
        
        requestType = reqArgs [0];
        
        reqObj = HttpRequest ();
        reqObj.headers = headers;        
        reqObj.method = requestType

        content = "";
        
        if (headers.contains ("Content-Length")) {
            n = headers ["Content-Length"];
            content = client.read (Int (n));
        }
        
        given (requestType) {
            when "GET" {
                path = reqArgs [1];
                if (path.contains ("?")) {
                    path = path.substr (0, path.find ("?"));
                    queryStr = reqArgs[1].substr (reqArgs [1].find ("?") + 1);
                    reqObj.parameters = parseQueryString (queryStr);
                }
                self.servePage (client, path, reqObj);
            }
            when "POST" {
                if (reqArgs [0].contains ("?")) {
                    path = reqArgs [0].substr (0, reqArgs [0].find ("?"));
                    queryStr = reqArgs [0].substr (reqArgs [0].find ("?") + 1);
                    reqObj.parameters = parseQueryString (queryStr);
                } 
                reqObj.postData = parseQueryString (content);
                self.servePage (client, reqArgs [1], reqObj);
            }
            
        }
    }
    
    func servePage (self, stream, path, requestObj) {
        headers = {
            "Content-Encoding" : "UTF-8",
            "Content-Type" : "text/html; charset=UTF-8",
            "Connection" : "close"
        };        
        
        content = "";
        requestObj.url = path;
        
        resp = HttpResponse ();
        
        if (requestObj.headers.contains ("Host")) {
            headers ["Origin"] = requestObj.headers ["Host"];
        }

        headers ["Access-Control-Allow-Origin"] = "*";
  

        self.handleRequest (resp, requestObj);
        
        content = Str (resp._response);
        
        status = _statusCodes [resp.statusCode];
        
        stream.write ("HTTP/1.1 #{status}\r\n");
        
        headers ["Content-Length"] = Str (len (content));
        
        for (key, value in headers) {
            stream.write (key);
            stream.write (": ");
            stream.write (value);
            stream.write ("\r\n");
        }
        
        
        stream.write ("\r\n");
        stream.write (content);
        stream.flush ();
    }
}


class SimpleHttpServer extends BaseHttpServer {
    
    func SimpleHttpServer (self) {
        super ();
        self._routes = {};
        self._defaultHandler = self.notFoundHandler;
    }
    
    func notFoundHandler (self, response, request) {
        response.statusCode = 404;
        response.writeln ("<html><head>");
        response.writeln ("<title>404 Not Found</title>");
        response.writeln ("</head><body>");
        response.writeln ("<h1>Not Found</h1>");
        response.writeln ("<p>The requested URL #{request.url} was not found on this server.</p>");
        response.writeln ("</body></html>");
    }
    
    func handle (self, route, handleFunc) {
        self._routes.set (route, handleFunc);
    }
    
    func handleRequest (self, response, request) {
        for (pattern, handler in self._routes) {
            if (regex.ismatch (request.url, pattern)) {
                handler (response, request);
                return true;
            }
        }
        self.notFoundHandler (response, request);
        return false;
    }
}
