/**
 * Module for creating documentation from iodine objects
 * @author GruntTheDivine
 */
 
use inspect
use __builtins__

contract DocumentationFormatter {
    func formatDoc (documentation)
}

class FunctionDocumentation {
    func FunctionDocumentation (self, name) {
        self.parameters = []
        self.optional_parameters = []
        self.description = ""
        self.name = name
    }    
    
    func add_parameter (self, name, description) {
        self.parameters.append ((name, description))
    }
            
    func add_optional_parameter (self, name, description) {
        self.optional_parameters.append ((name, description))
    }
    
    func set_description (self, description) {
        self.description = description
    }
}

class ClassDocumentation {
    func ClassDocumentation (self, name) {
        self.parameters = []
        self.optional_parameters = []
        self.description = ""
        self.name = name
    }
    
    func add_parameter (self, name, description) {
        self.parameters.append ((name, description))
    }
        
    func add_optional_parameter (self, name, description) {
        self.optional_parameters.append ((name, description))
    }
    
    func set_description (self, description) {
        self.description = description
    }
}


func _parse_function_doc (obj, lines) {
    
    text = StringBuffer ();
    
    for (line in lines) {
        if (line.startswith ("@param")) {
            name, type, description = _parse_param_tag (line)
            
            obj.add_parameter (name, description)
            
        }
        else if (line.startswith ("@optional")) {
            name, type, description = _parse_param_tag (line)
            
            obj.add_optional_parameter (name, description)
        }
        else {
            text.append (line)
        }
    }
    
    obj.set_description (Str (text))
}

func _parse_param_tag (line) {
    tokens = line.split (' ');
    
    if (len (line) > 2) {
        name = tokens [1];
        type = null;
        description = null;
        
        if (tokens [2] == ":") {
            type = tokens [3];
            description = " ".join (tokens [4::1]);
        } else if (tokens [2].startswith (":")) {
            type = tokens [2].substr (1);
            description = " ".join (tokens [3::1]);
        } else if (name.contains (":")) {
            name = tokens [1].substr (0, name.find (":"));
            type = tokens [1].substr (tokens [1].find (":") + 1);
            description = " ".join (tokens [2::1]);
        } else {
            description = " ".join (tokens [2::1]);
        }
        
        return (name, type, description);
    }       
    raise Exception ("Invalid param tag");
}

class HtmlFormatter {
    func HtmlFormatter (self) {
        self.indentLevel = 0;
    }
    
    
    func format_func (self, function) {
        
    }
}

class MarkdownFormatter {
    
    func MarkdownFormatter (self) {
        self.headingLevel = 2
    }
    
    
    func format_module (self, output, moduleName, moduleDoc, items) {
        
        output.writeln ("## ```#{moduleName}``` module")
        output.writeln ("")
        
        if (len (moduleDoc) > 0) {
            output.writeln (moduleDoc)
        }
        
        classes = items.filter (lambda (p) => p is ClassDocumentation)
        
        funcs = items.filter (lambda (p) => p is FunctionDocumentation)
        
       if (len  (funcs) > 0) { 
        
            output.writeln ("### Functions")
            output.writeln ("")
            funcs.each (lambda (funcDoc) {
                self.format_module_func (output, funcDoc)
            })
        
        }
        output.writeln ("")
        
        classes.each (lambda (classdoc) {
            self.format_class (output, classdoc)

        })
        
        output.writeln ("")
    }
    
    func format (self, output, items) {
        
        classes = items.filter (lambda (p) => p is ClassDocumentation)
        
        funcs = items.filter (lambda (p) => p is FunctionDocumentation)
        
       if (len  (funcs) > 0) { 
        
            output.writeln ("##### Methods")
            output.writeln ("")
            
            output.writeln ("| Name                    | Arguments         | Description |")
            output.writeln ("| ----------------------- | ----------------- | ----------- |")
            
            funcs.each (lambda (funcDoc) {
                self.format_func (output, funcDoc)
            })
        
        }
        output.writeln ("")
        
        classes.each (lambda (classdoc) {
            self.format_class (output, classdoc)

        })
        
        output.writeln ("")

    }
    
    func format_class (self, output, classdecl) {

        output.write ("#### class ```#{classdecl.name}```")

        
        argnames = classdecl.parameters.map (lambda (p) => p [0])
        
        opt_argnames = classdecl.optional_parameters.map (
            lambda (p) => "[" + p[0] + "]"
        )
        
        argnames.appendrange (opt_argnames)
        
        output.writeln (" ({})".format (", ".join (argnames)))
        
        output.writeln ("___")
        
        output.writeln (classdecl.description)

        self.format (output, classdecl.members)
        
    }
    
    func format_module_func (self, output, funcdoc) {

        output.write ("#### func ```#{funcdoc.name}```")

        
        argnames = funcdoc.parameters.map (lambda (p) => p [0])
        
        opt_argnames = funcdoc.optional_parameters.map (
            lambda (p) => "[" + p[0] + "]"
        )
        
        argnames.appendrange (opt_argnames)
        
        output.writeln (" ({})".format (", ".join (argnames)))
        
        output.writeln ("___")
        
        output.writeln (funcdoc.description)
        
    }
    
    func format_func (self, output, function) {
        headings = [
            "",
            "#",
            "##",
            "###",
            "####",
            "#####",
            "######"
        ]
        
        
        output.write ("|")
        
        output.write ("#{function.name}")
        
        argnames = function.parameters.map (lambda (p) => p [0])
        
        opt_argnames = function.optional_parameters.map (
            lambda (p) => "[" + p[0] + "]"
        )
        
        argnames.appendrange (opt_argnames)
        
        if (len (argnames) > 0) {
            output.write ("| {} |".format (", ".join (argnames)))
        }
        else {
            output.write ("| **None** |")
        }
        output.writeln (function.description + "|")
    }
}

func compiledoc (obj, *args) {
    items = [];
    
    _compileAttributes (items, inspect.getmembers (obj))
    
    items = sort (items, lambda (p) => p.name)
    
    return items;
}

func _compileAttributes (items, attrs) {
    for (name, attr in attrs) {
        if (inspect.hasattribute (attr, "__doc__")) {
            lines = attr.__doc__.split ("\n")
            
            if (inspect.ismethod (attr) || inspect.isbuiltin (attr)) {
                funcdoc = FunctionDocumentation (name)
                
                _parse_function_doc (funcdoc, lines) 
                
                items.append (funcdoc);
            }
            
            if (inspect.istype (attr)) {
                classdoc = ClassDocumentation (name)
                                
                _parse_function_doc (classdoc, lines) 
                
                classattr = []
                
                _compileAttributes (classattr, inspect.getmembers (attr))
                
                classdoc.members = classattr
                
                items.append (classdoc)
            }
        }
    }
}
