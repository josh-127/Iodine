/**
 * Module for creating documentation from iodine objects
 * @author GruntTheDivine
 */
 
use inspect
use __builtins__

contract DocumentationFormatter {
    func formatDoc (documentation)
}

class FunctionDocumentation {
    func FunctionDocumentation (self, name) {
        self.parameters = []
        self.optional_parameters = []
        self.description = ""
        self.name = name
    }    
    
    func add_parameter (self, name, description) {
        self.parameters.append ((name, description))
    }
            
    func add_optional_parameter (self, name, description) {
        self.optional_parameters.append ((name, description))
    }
    
    func set_description (self, description) {
        self.description = description
    }
}

class ClassDocumentation {
    func ClassDocumentation (self, name) {
        self.parameters = []
        self.optional_parameters = []
        self.description = ""
        self.name = name
    }
    
    func add_parameter (self, name, description) {
        self.parameters.append ((name, description))
    }
        
    func add_optional_parameter (self, name, description) {
        self.optional_parameters.append ((name, description))
    }
    
    func set_description (self, description) {
        self.description = description
    }
}


func _parse_function_doc (obj, lines) {
    
    text = StringBuffer ();
    
    for (line in lines) {
        if (line.startswith ("@param")) {
            name, type, description = _parse_param_tag (line)
            
            obj.add_parameter (name, description)
            
        }
        else if (line.startswith ("@optional")) {
            name, type, description = _parse_param_tag (line)
            
            obj.add_optional_parameter (name, description)
        }
        else {
            text.append (line)
        }
    }
    
    obj.set_description (Str (text))
}

func _parse_param_tag (line) {
    tokens = line.split (' ');
    
    if (len (line) > 2) {
        name = tokens [1];
        type = null;
        description = null;
        
        if (tokens [2] == ":") {
            type = tokens [3];
            description = " ".join (tokens [4::1]);
        } else if (tokens [2].startswith (":")) {
            type = tokens [2].substr (1);
            description = " ".join (tokens [3::1]);
        } else if (name.contains (":")) {
            name = tokens [1].substr (0, name.find (":"));
            type = tokens [1].substr (tokens [1].find (":") + 1);
            description = " ".join (tokens [2::1]);
        } else {
            description = " ".join (tokens [2::1]);
        }
        
        return (name, type, description);
    }       
    raise Exception ("Invalid param tag");
}

class HtmlFormatter {
    func HtmlFormatter (self) {
        self.indentLevel = 0;
    }
    
    
    func format_func (self, function) {
        
    }
}

class TerminalFormatter {
    func TerminalFormatter (self) {

    }

    func format_module (self, output, moduleName, moduleDoc, items) {
        
        self.write_title (output, "NAME")
        
        self.write_indent (output, moduleName, 1)

        self.write_title (output, "DESCRIPTION")

        self.write_indent (output, moduleDoc, 1)
 
        classes = items.filter (lambda (p) => p is ClassDocumentation)
        
        funcs = items.filter (lambda (p) => p is FunctionDocumentation)

        if (len (classes) > 0) {
            self.write_title (output, "CLASSES")

            classes.each (lambda (p) => self.format_module_class (output, p))
        }
        
        if (len (funcs) > 0) {
            self.write_title (output, "FUNCTIONS")

            funcs.each (lambda (p) => self.format_module_func (output, p))
        } 
        
    }

    func format_module_func (self, output, funcdoc) {

        output.write ("    ")

        self.write_bold (output, "#{funcdoc.name}(...)")

        output.writeln ("")

        argnames = funcdoc.parameters.map (lambda (p) => p [0])

        opt_argnames = funcdoc.optional_parameters.map (
            lambda (p) => "[" + p[0] + "]"
        )

        argnames.appendrange (opt_argnames)

        output.write ("        ")

        self.write_bold (output, funcdoc.name)

        output.writeln ("({})".format (funcdoc.name, ", ".join (argnames)))
        
        output.writeln ("")
       
        self.write_indent (output, funcdoc.description, 2)


        output.writeln ("")
    }
   

    func format_module_class (self, output, classdoc) {
       
        argnames = classdoc.parameters.map (lambda (p) => p [0])

        opt_argnames = classdoc.optional_parameters.map (
            lambda (p) => "[" + p[0] + "]"
        )

        func new_line () => self.write_tree (output, "", 2, 2)
        
        func print_line (text, indent=2, newline=true) => self.write_tree (
            output, text, indent, 2, newline
        )

        argnames.appendrange (opt_argnames)

        self.write_indent (output, "class ", 1, false)

        self.write_bold (output, classdoc.name)

        output.writeln ("({})".format (", ".join (argnames)))

        new_line ()

        print_line (classdoc.description)

        methods = classdoc.members.filter (lambda (p) => p is FunctionDocumentation)

        new_line ()

        if (len (methods) > 0) {
            
            print_line ("Methods defined here:")
            
            new_line ()            
        }

        for (member in methods) {
         
            print_line ("", 2, false)
         
            self.write_bold (output, member.name)
            
            output.writeln ("(...)")
            
            print_line (member.description, 3)

            new_line ()    
        }

        output.writeln ("")
    }
 
    func write_tree (self, output, str, indent_level, tree_level, new_line=true) {
        real_ilevel = indent_level - tree_level

        padding = "| ".rjust (tree_level * 4 - 2)

        padding += "".rjust (real_ilevel * 4)

        self._write_indent (output, str, padding, new_line)
    }

    func write_indent (self, output, str, indent_level, new_line=true) {
        padding = "".rjust (indent_level * 4)

        self._write_indent (output, str, padding, new_line)
    }

    func _write_indent (self, output, str, indent_str, new_line) {
        
        output.write (indent_str)

        words = str.split (' ')

        lineLen = 0                     # Tracks the amount of characters present on a given line
        maxLen = 80 - len (indent_str)  # Maximum length before word wrap

        for (word in words) {
            lineLen += len (word) + 1

            if (lineLen < 80) {
                output.write (word, " ")
            } else {
                lineLen = 0
                output.writeln ("")
                output.write (indent_str)
                output.write (word)
            }
        }

        if (new_line) {
            output.writeln ("")
        }
    }

    func write_title (self, output, str) {
        esc = chr (0x1B) # Hack until I add an escape sequence for numeric character values
        output.writeln ("")
        output.write ("#{esc}[1m")
        output.writeln (str)
        output.write ("#{esc}[0m")
    }

    func write_bold (self, output, str) {
        esc = chr (0x1B)

        output.write ("#{esc}[1m")
        output.write (str)
        output.write ("#{esc}[0m")
    }

    func disable_terminal_attr (self, output) {
        esc = chr (0x1B)
        output.write ("#{esc}[0m")
    }
}

class MarkdownFormatter {
    
    func MarkdownFormatter (self) {
        self.headingLevel = 2
    }
    
    
    func format_module (self, output, moduleName, moduleDoc, items) {
        
        output.writeln ("## ```#{moduleName}``` module")
        output.writeln ("")
        
        if (len (moduleDoc) > 0) {
            output.writeln (moduleDoc)
        }
        
        classes = items.filter (lambda (p) => p is ClassDocumentation)
        
        funcs = items.filter (lambda (p) => p is FunctionDocumentation)
        

        if (len  (funcs) > 0) { 
        
            output.writeln ("### Functions")
            output.writeln ("")
            funcs.each (lambda (funcDoc) {
                self.format_module_func (output, funcDoc)
            })
        
        }
        output.writeln ("")
        
        classes.each (lambda (classdoc) {
            self.format_class (output, classdoc)

        })
        
        output.writeln ("")
    }
    
    func format (self, output, items) {
        
        classes = items.filter (lambda (p) => p is ClassDocumentation)
        
        funcs = items.filter (lambda (p) => p is FunctionDocumentation)
        
       if (len  (funcs) > 0) { 
        
            output.writeln ("##### Methods")
            output.writeln ("")
            
            output.writeln ("| Name                    | Arguments         | Description |")
            output.writeln ("| ----------------------- | ----------------- | ----------- |")
            
            funcs.each (lambda (funcDoc) {
                self.format_func (output, funcDoc)
            })
        
        }
        output.writeln ("")
        
        classes.each (lambda (classdoc) {
            self.format_class (output, classdoc)

        })
        
        output.writeln ("")

    }
    
    func format_class (self, output, classdecl) {

        output.write ("#### class ```#{classdecl.name}```")

        
        argnames = classdecl.parameters.map (lambda (p) => p [0])
        
        opt_argnames = classdecl.optional_parameters.map (
            lambda (p) => "[" + p[0] + "]"
        )
        
        argnames.appendrange (opt_argnames)
        
        output.writeln (" ({})".format (", ".join (argnames)))
        
        output.writeln ("___")
        
        output.writeln (classdecl.description)

        self.format (output, classdecl.members)
        
    }
    
    func format_module_func (self, output, funcdoc) {

        output.write ("#### func ```#{funcdoc.name}```")

        
        argnames = funcdoc.parameters.map (lambda (p) => p [0])
        
        opt_argnames = funcdoc.optional_parameters.map (
            lambda (p) => "[" + p[0] + "]"
        )
        
        argnames.appendrange (opt_argnames)
        
        output.writeln (" ({})".format (", ".join (argnames)))
        
        output.writeln ("___")
        
        output.writeln (funcdoc.description)
        
    }
    
    func format_func (self, output, function) {
        headings = [
            "",
            "#",
            "##",
            "###",
            "####",
            "#####",
            "######"
        ]
        
        
        output.write ("|")
        
        output.write ("#{function.name}")
        
        argnames = function.parameters.map (lambda (p) => p [0])
        
        opt_argnames = function.optional_parameters.map (
            lambda (p) => "[" + p[0] + "]"
        )
        
        argnames.appendrange (opt_argnames)
        
        if (len (argnames) > 0) {
            output.write ("| {} |".format (", ".join (argnames)))
        }
        else {
            output.write ("| **None** |")
        }
        output.writeln (function.description + "|")
    }
}

func compiledoc (obj, *args) {
    items = [];
    
    _compileAttributes (items, inspect.getmembers (obj))
    
    items = sort (items, lambda (p) => p.name)
    
    return items;
}

func _compileAttributes (items, attrs) {
    for (name, attr in attrs) {
        if (inspect.hasattribute (attr, "__doc__")) {
            lines = attr.__doc__.split ("\n")
            
            if (inspect.ismethod (attr) || inspect.isbuiltin (attr)) {
                funcdoc = FunctionDocumentation (name)
                
                _parse_function_doc (funcdoc, lines) 
                
                items.append (funcdoc);
            }
            
            if (inspect.istype (attr)) {
                classdoc = ClassDocumentation (name)
                                
                _parse_function_doc (classdoc, lines) 
                
                classattr = []
                
                _compileAttributes (classattr, inspect.getmembers (attr))
                
                classdoc.members = classattr
                
                items.append (classdoc)
            }
        }
    }
}
