/**
 * For parsing semantic versioning
 * Licensed under the MIT license
 * @module semver
 * @author Aurora01
 * @version v0.2.0
 */

/**
 * Class representing a semantic version (MAJOR, MINOR, PATCH)
 */
class SemanticVersion {
    func SemanticVersion (self, *args) {
        if len (args) == 1 {
            self.versionString = args [0]
            self._parseVersionString ()
        }
        else if len (args) >= 2 {
            argList = List () + args
            while len (argList) < 4 {
                argList.append (null)
            }
            self._createVersionString (argList [0], argList [1], argList [2], 
                                       argList [3])
        }
        else {
            raise ArgumentException ("Argument exception!")
        }
    }
   
    /**
     * Returns true if the version is an alpha version
     * @returns True if the major is 0
     */ 
    func isAlpha (self) {
        return self.versionMajor == 0
    }
    
    func _parseVersionString (self) {
        ver = self.versionString
        
        if self.versionString.startswith ("v") {
            ver = self.versionString.substr (1)
        }
        
        verSplit = ver.split ("-")
        versionBase = verSplit [0].split (".")
        if len (verSplit) == 2 {
            self.versionTag = verSplit [1]
        }
        
        for i in range (3) {
            if len (versionBase) <= i {
                versionBase.append (0)
            }
            else {
                versionBase [i] = Int (versionBase [i])
            }
        }
        
        self.versionMajor = versionBase [0]
        self.versionMinor = versionBase [1]
        self.versionPatch = versionBase [2]
    }
    
    func _createVersionString (self, major, minor, patch, tag) {
        if patch is Null {
            patch = 0
        }
        fmt = "v{}.{}.{}"
        ver = fmt.format (major, minor, patch)
        if tag isnot Null && tag != "" {
            ver += "-{}".format (tag)
        } 
        self.versionString = ver
        self._parseVersionString ()
    }
    
    /**
     * Tests if this version is greater than the supplied argument
     * @param version The version to compare with
     * @returns True if this version is greater than the supplied argument
     */
    func isGreaterThan (self, version) {
        ver = SemanticVersion (version)
        
        if ver.versionMajor < self.versionMajor {
            return true
        }
        else if ver.versionMajor > self.versionMajor {
            return false
        }
        
        if ver.versionMinor < self.versionMinor {
            return true
        }
        else if ver.versionMinor > self.versionMinor {
            return false
        }
        
        if ver.versionPatch < self.versionPatch {
            return true
        }
        
        return false  
    }
 
    /**
     * Tests whether or not this version is greater than or equal the supplied
     * argument
     * @param version The version to compare with
     * @returns True if this version is greater than or equal to version
     */   
    func isGTE (self, version) {
        ver = SemanticVersion (version)
        if ver.versionMajor == self.versionMajor
           && ver.versionMinor == self.versionMinor
           && ver.versionPatch == self.versionPatch {
            return true
        }
        return self.isGreaterThan (version)
    }
    
    /**
     * Tests if this version is less than or equal to the supplied argument
     * @param version The version to compare to
     * @returns True if this version is less than or equal to version
     */
    func isLTE (self, version) {
        ver = SemanticVersion (version)
        if ver.versionMajor == self.versionMajor
           && ver.versionMinor == self.versionMinor
           && ver.versionPatch == self.versionPatch {
            return true
        }
        return self.isLessThan (version)
    }
    
    /**
     * Tests if this version is less than the supplied argument
     * @param version The version to compare to
     * @returns Truee if this version is less than the supplied argument
     */
    func isLessThan (self, version) {
        ver = SemanticVersion (version)
        
        if ver.versionMajor > self.versionMajor {
            return true
        }
        else if ver.versionMajor < self.versionMajor {
            return false
        }
        
        if ver.versionMinor > self.versionMinor {
            return true
        }
        else if ver.versionMinor < self.versionMinor {
            return false
        }
        
        if ver.versionPatch > self.versionPatch {
            return true
        }
        
        return false
    }
    
    /**
     * Tests if this version is equal to the supplied argument
     * @param ver The version to compare to
     * @returns True if this is equal to ver
     */
    func isEqual (self, ver) {
        v = SemanticVersion (ver)
        if v.versionMajor == self.versionMajor && 
           v.versionMinor == self.versionMinor && 
           v.versionPatch == self.versionPatch {
            return true
        }
        return false
    }
 
    /**
     * Tests to see if this version matches a semantic version string
     * @param requestedVersion The version string to match
     * @returns True if match
     */   
    func isMatch (self, requestedVersion) {
        if requestedVersion == "*" {
            return true
        }
        
        if requestedVersion.startswith ("~") {
            return self._isTildeMatch (requestedVersion)
        }
        
        if requestedVersion.startswith ("^") {
            return self._isCaretMatch (requestedVersion)
        }
        
        reqVer = requestedVersion.split (" ")
        if reqVer.contains ("-") {
            return self._isRangeMatch (reqVer)
        }
        
        conds = List ()
        
        for v in reqVer {
            if v.startswith (">=") {
                conds.append (self.isGTE (v.substr (2)))
            }
            else if v.startswith (">") {
                conds.append (self.isGreaterThan (v.substr (1)))
            }
            else if v.startswith ("<=") {
                conds.append (self.isLTE (v.substr (2)))
            }
            else if v.startswith ("<") {
                conds.append (self.isLessThan (v.substr (1)))
            }
            else {
                conds.append (self.isEqual (v))
            }
        }
        if !conds.contains (false) {
            return true
        }
        
        return false
    }
    
    func _isRangeMatch (self, reqVer) {
        if len (reqVer) != 3 {
            return false
        }
       
        
        if self.isGTE (reqVer [0]) && self.isLTE (reqVer [2]) {
            return true
        }
        
        return false
    }
    
    func _isTildeMatch (self, requestedVersion) {
        ver = SemanticVersion (requestedVersion.substr (1))
        if ver.versionMajor == self.versionMajor &&
           ver.versionMinor == self.versionMinor &&
           ver.versionPatch <= self.versionPatch {
            return true    
        }
        return false
    }
    
    func _isCaretMatch (self, requestedVersion) {
        ver = SemanticVersion (requestedVersion.substr (1))
        if ver.versionMajor == self.versionMajor {
            if ver.versionMinor == self.versionMinor &&
               ver.versionPatch <= self.versionPatch {
                return true   
            }
            if ver.versionMinor < self.versionMinor {
                return true
            }
        }
        return false
    }
}
