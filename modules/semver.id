/**
 * For parsing semantic versioning
 * Licensed under the MIT license
 * @module semver
 * @author Aurora01
 * @version v0.2.0
 */

/**
 * Class representing a semantic version (MAJOR, MINOR, PATCH)
 */
class SemanticVersion {
    func SemanticVersion (self, *args) {
        if (len (args) == 1) {
            self.versionString = args [0];
            self._parseVersionString ();
        }
        else if (len (args) >= 2) {
            argList = List () + args;
            while (len (argList) < 4) {
                argList.add (null);
            }
            self._createVersionString (argList [0], argList [1], argList [2], 
                                       argList [3]);
        }
        else {
            raise ArgumentException ("Argument exception!");
        }
    }
   
    /**
     * Returns true if the version is an alpha version
     * @returns True if the major is 0
     */ 
    func isAlpha (self) {
        return self.versionMajor == 0;
    }
    
    func _parseVersionString (self) {
        ver = self.versionString;
        if (self.versionString.startsWith ("v")) {
            ver = self.versionString.substr (1);
        }
        
        verSplit = ver.split ("-");
        versionBase = verSplit [0].split (".");
        if (len (verSplit) == 2) {
            self.versionTag = verSplit [1];
        }
        
        foreach (i in range (3)) {
            if (len (versionBase) <= i) {
                versionBase.add (0);
            }
            else {
                versionBase [i] = Int (versionBase [i]);
            }
        }
        
        self.versionMajor = versionBase [0];
        self.versionMinor = versionBase [1];
        self.versionPatch = versionBase [2];
    }
    
    func _createVersionString (self, major, minor, patch, tag) {
        if (null == patch) {
            patch = 0;
        }
        fmt = "v{}.{}.{}";
        ver = fmt.format (major, minor, patch);
        if (tag != null && tag != "") {
            ver += "-{}".format (tag);
        } 
        self.versionString = ver;
        self._parseVersionString ();
    }
    
    /**
     * Tests if this version is greater than the supplied argument
     * @param version The version to compare with
     * @returns True if this version is greater than the supplied argument
     */
    func isGreaterThan (self, version) {
        ver = SemanticVersion (version);
        
        if (ver.versionMajor < self.versionMajor) {
            return true;
        }
        else if (ver.versionMajor > self.versionMajor) {
            return false;
        }
        
        if (ver.versionMinor < self.versionMinor) {
            return true;
        }
        else if (ver.versionMinor > self.versionMinor) {
            return false;
        }
        
        if (ver.versionPatch < self.versionPatch) {
            return true;
        }
        
        return false;    
    }
 
    /**
     * Tests whether or not this version is greater than or equal the supplied
     * argument
     * @param version The version to compare with
     * @returns True if this version is greater than or equal to version
     */   
    func isGTE (self, version) {
        ver = SemanticVersion (version);
        if (ver.versionMajor == self.versionMajor && ver.versionMinor == 
            self.versionMinor && ver.versionPatch == self.versionPatch) {
            return true;
        }
        return self.isGreaterThan (version);
    }
    
    /**
     * Tests if this version is less than or equal to the supplied argument
     * @param version The version to compare to
     * @returns True if this version is less than or equal to version
     */
    func isLTE (self, version) {
        ver = SemanticVersion (version);
        if (ver.versionMajor == self.versionMajor && ver.versionMinor == 
            self.versionMinor && ver.versionPatch == self.versionPatch) {
            return true;
        }
        return self.isLessThan (version);
    }
    
    /**
     * Tests if this version is less than the supplied argument
     * @param version The version to compare to
     * @returns Truee if this version is less than the supplied argument
     */
    func isLessThan (self, version) {
        ver = SemanticVersion (version);
        
        if (ver.versionMajor > self.versionMajor) {
            return true;
        }
        else if (ver.versionMajor < self.versionMajor) {
            return false;
        }
        
        if (ver.versionMinor > self.versionMinor) {
            return true;
        }
        else if (ver.versionMinor < self.versionMinor) {
            return false;
        }
        
        if (ver.versionPatch > self.versionPatch) {
            return true;
        }
        
        return false;
    }
    
    /**
     * Tests if this version is equal to the supplied argument
     * @param ver The version to compare to
     * @returns True if this is equal to ver
     */
    func isEqual (self, ver) {
        v = SemanticVersion (ver);
        if (v.versionMajor == self.versionMajor && 
            v.versionMinor == self.versionMinor && 
            v.versionPatch == self.versionPatch) {
            return true;
        }
        return false;
    }
 
    /**
     * Tests to see if this version matches a semantic version string
     * @param requestedVersion The version string to match
     * @returns True if match
     */   
    func isMatch (self, requestedVersion) {
        if (requestedVersion == "*") {
            return true;
        }
        
        if (requestedVersion.startsWith ("~")) {
            return self._isTildeMatch (requestedVersion);
        }
        
        if (requestedVersion.startsWith ("^")) {
            return self._isCaretMatch (requestedVersion);
        }
        
        reqVer = requestedVersion.split (" ");
        if (reqVer.contains ("-")) {
            return self._isRangeMatch (reqVer);
        }
        
        conds = List ();
        
        foreach (v in reqVer) {
            if (v.startsWith (">=")) {
                conds.add (self.isGTE (v.substr (2)));
            }
            else if (v.startsWith (">")) {
                conds.add (self.isGreaterThan (v.substr (1)));
            }
            else if (v.startsWith ("<=")) {
                conds.add (self.isLTE (v.substr (2)));
            }
            else if (v.startsWith ("<")) {
                conds.add (self.isLessThan (v.substr (1)));
            }
            else {
                conds.add (self.isEqual (v));
            }
        }
        if (!conds.contains (false)) {
            return true;
        }
        
        return false;
    }
    
    func _isRangeMatch (self, reqVer) {
        if (len (reqVer) != 3) {
            return false;
        }
       
        
        if (self.isGTE (reqVer [0]) && self.isLTE (reqVer [2])) {
            return true;
        }
        
        return false;
    }
    
    func _isTildeMatch (self, requestedVersion) {
        ver = SemanticVersion (requestedVersion.substr (1));
        if (ver.versionMajor == self.versionMajor && ver.versionMinor == 
            self.versionMinor && ver.versionPatch <= self.versionPatch) {
            return true;    
        }
        return false;
    }
    
    func _isCaretMatch (self, requestedVersion) {
        ver = SemanticVersion (requestedVersion.substr (1));
        if (ver.versionMajor == self.versionMajor) {
            if (ver.versionMinor == self.versionMinor && ver.versionPatch <=
                self.versionPatch) {
                return true;   
            }
            if (ver.versionMinor < self.versionMinor) {
                return true;
            }
        }
        return false;
    }
}
